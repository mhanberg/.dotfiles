worker_processes 1;
pid ./nginx.pid;

events {
    worker_connections 1024;
}

http {
    access_log ./http_access.log;
    server {
        listen 8080;
        listen [::]:8080;
        server_name localhost;

        location /up {
            default_type text/plain;
            return 200 'OK';
            add_header Content-Length 2;
        }
    }
}

rtmp {
  server {
  listen 1935;
  chunk_size 4096;

  access_log ./rtmp_access.log;

  application live {
    record off;
    live on;

    # YouTube
    exec ./transcode.sh rtmp://localhost:1935/live/$name 15000 rtmp://a.rtmp.youtube.com/live2/hp6v-xyb6-4d4u-yaxm-ev1w;
    # Twitter
    # exec /gorgon/transcode.sh rtmp://localhost:1935/live/$name 9000 rtmp://va.pscp.tv:80/x/${TWITTER_STREAM_KEY};
    # # Twitch
    exec ./transcode.sh rtmp://localhost:1935/live/$name 6000 rtmp://ord03.contribute.live-video.net/app/live_276332985_DLFwUG3xXnvGLddyxgl6WloN2dy5Uf;

    # exec_kill_signal term;

    # when streaming starts
        # touch a .live file
        # make sure to kill the backup stream

    # on stream end
        # start the backup stream, this will cover temp disconnections
        # remove the .live file
        # wait five minutes
        # if no stream comes back on, kill nginx which should kill the machine on fly

    }
  }
}
